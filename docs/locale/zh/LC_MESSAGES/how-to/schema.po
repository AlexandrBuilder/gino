# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-present, Fantix King
# This file is distributed under the same license as the GINO package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GINO \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-23 02:02-0600\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:3
msgid "Schema Declaration"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:5
msgid "Table of Contents"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:7
msgid ""
"There are 3 ways to declare your database schema to be used with GINO. "
"Because GINO is built on top of SQLAlchemy core, either way you are "
"actually declaring SQLAlchemy :class:`~sqlalchemy.schema.Table`."
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:13
msgid "GINO Engine"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:15
msgid ""
"This is the minimized way to use GINO - using only "
":class:`~gino.engine.GinoEngine` (and "
":class:`~gino.engine.GinoConnection` too), everything else are vanilla "
"SQLAlchemy core. This is useful when you have legacy code written in "
"SQLAlchemy core, in need of porting to asyncio. For new code please use "
"the other two."
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:21
msgid ""
"For example, the table declaration is the same as SQLAlchemy core "
"`tutorial <https://docs.sqlalchemy.org/en/latest/core/tutorial.html>`_::"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:46
msgid ""
"When using GINO Engine only, it is usually your own business to create "
"the tables with either :meth:`~sqlalchemy.schema.MetaData.create_all` on "
"a normal non-async SQLAlchemy engine, or using Alembic. However it is "
"still possible to be done with GINO if it had to::"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:58
msgid "Then, construct queries, in SQLAlchemy core too::"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:62
msgid ""
"So far, everything is still in SQLAlchemy. Now let's get connected and "
"execute the insert::"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:72
msgid ""
"Here :func:`~gino.create_engine` creates a "
":class:`~gino.engine.GinoEngine`, then "
":meth:`~gino.engine.GinoEngine.acquire` checks out a "
":class:`~gino.engine.GinoConnection`, and "
":meth:`~gino.engine.GinoConnection.status` executes the insert and "
"returns the status text. This works similarly as SQLAlchemy "
":meth:`~sqlalchemy.engine.Connection.execute` - they take the same "
"parameters but return a bit differently. There are also other similar "
"query APIs:"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:80
msgid ""
":meth:`~gino.engine.GinoConnection.all` returns a list of "
":class:`~sqlalchemy.engine.RowProxy`"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:82
msgid ""
":meth:`~gino.engine.GinoConnection.first` returns one "
":class:`~sqlalchemy.engine.RowProxy`, or ``None``"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:84
msgid ""
":meth:`~gino.engine.GinoConnection.one` returns one "
":class:`~sqlalchemy.engine.RowProxy`"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:86
msgid ""
":meth:`~gino.engine.GinoConnection.one_or_none` returns one "
":class:`~sqlalchemy.engine.RowProxy`, or ``None``"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:88
msgid ""
":meth:`~gino.engine.GinoConnection.scalar` returns a single value, or "
"``None``"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:90
msgid ""
":meth:`~gino.engine.GinoConnection.iterate` returns an asynchronous "
"iterator which yields :class:`~sqlalchemy.engine.RowProxy`"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:93
msgid "Please go to their API for more information."
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:97
msgid "GINO Core"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:99
msgid ""
"In previous scenario, :class:`~gino.engine.GinoEngine` must not be set to"
" :attr:`metadata.bind <sqlalchemy.schema.MetaData.bind>` because it is "
"not a regular SQLAlchemy Engine thus it won't work correctly. For this, "
"GINO provides a subclass of :class:`~sqlalchemy.schema.MetaData` as "
":class:`~gino.api.Gino`, usually instantiated globally under the name of "
"``db``. It can be used as a normal :class:`~sqlalchemy.schema.MetaData` "
"still offering some conveniences:"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:106
msgid "It delegates most public types you can access on ``sqlalchemy``"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:107
msgid "It works with both normal SQLAlchemy engine and asynchronous GINO engine"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:108
msgid "It exposes all query APIs on :class:`~gino.engine.GinoConnection` level"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:109
msgid ""
"It injects two ``gino`` extensions on SQLAlchemy query clauses and schema"
" items, allowing short inline execution like "
"``users.select().gino.all()``"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:111
msgid "It is also the entry for the third scenario, see later"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:113
msgid "Then we can achieve previous scenario with less code like this::"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:145
msgid ""
"Similar to SQLAlchemy core and ORM, this is GINO core. All tables and "
"queries are still made of SQLAlchemy whose rules still apply, but "
"``sqlalchemy`` seems never imported. This is useful when ORM is unwanted."
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:151
msgid ""
"`asyncpgsa <https://github.com/CanopyTax/asyncpgsa/>`_ does the same "
"thing, but in a conceptually reversed way - instead of having asyncpg "
"work for SQLAlchemy, it made SQLAlchemy work for asyncpg (GINO used to be"
" in that way too because GINO is inspired by asyncpgsa). Either way works"
" fine, it's just a matter of taste of whose API style to use, SQLAlchemy "
"or asyncpg."
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:159
msgid "GINO ORM"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:161
msgid ""
"If you want to further reduce the length of code, and taking a bit risk "
"of implicity, welcome to the ORM world. Even though GINO made itself not "
"quite a traditional ORM by being simple and explict to safely work with "
"asyncio, common ORM concepts are still valid - a table is a model class, "
"a row is a model instance. Still the same example rewritten in GINO ORM::"
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:197
msgid "The ``__tablename__`` is a mandatory field to define a concrete model."
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:199
msgid ""
"As you can see, the declaration is pretty much the same as before. "
"Underlying they are identical, declaring two tables in ``db``. The "
"``class`` style is just more declarative. Instead of ``users.c.name``, "
"you can now access the column by ``User.name``. The implicitly created "
":class:`~sqlalchemy.schema.Table` is available at ``User.__table__`` and "
"``Address.__table__``. You can use anything that works in GINO core here."
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:208
msgid ""
"Column names can be different as a class property and database column. "
"For example, name can be declared as ``nickname = db.Column('name', "
"db.Unicode(), default='noname')``. In this example, ``User.nickname`` is "
"used to access the column, while in database, the column name is "
"``name``."
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:214
msgid ""
"What's worth mentioning is where raw SQL statements are used, or "
"``TableClause`` is involved, like ``User.insert()``, the original name is"
" required to be used, because in this case, GINO has no knowledge about "
"the mappings."
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:221
msgid ""
"``db.Model`` is a dynamically created parent class for your models. It is"
" associated with the ``db`` on initialization, therefore the table is put"
" in the very ``db`` when you declare your model class."
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:225
msgid ""
"Things become different when it comes to CRUD. You can use model level "
"methods to directly :meth:`~gino.crud.CRUDModel.create` a model instance,"
" instead of inserting a new row. Or :meth:`~gino.crud.CRUDModel.delete` a"
" model instance without needing to specify the where clause manually. "
"Query returns model instances instead of "
":class:`~sqlalchemy.engine.RowProxy`, and row values are directly "
"available as attributes on model instances. See also: :doc:`/how-"
"to/crud`."
msgstr ""

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/how-to/schema.rst:233
msgid ""
"After all, :class:`~gino.engine.GinoEngine` is always in use. Next let's "
"dig more into it."
msgstr ""

