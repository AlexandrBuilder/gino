# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-present, Fantix King
# This file is distributed under the same license as the GINO package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GINO \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-23 02:02-0600\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Volumes/Home/fantix/PycharmProjects/gino/docs/reference/api/gino.engine.rst:2
msgid "gino.engine module"
msgstr ""

#: gino.engine.GinoConnection:1 gino.engine.GinoEngine:1 of
msgid "Bases: :class:`object`"
msgstr ""

#: gino.engine.GinoConnection:1 of
msgid "Represents an actual database connection."
msgstr ""

#: gino.engine.GinoConnection:3 of
msgid ""
"This is the root of all query API like :meth:`all`, :meth:`first`, "
":meth:`one`, :meth:`one_or_none`, :meth:`scalar` or :meth:`status`, those"
" on engine or query are simply wrappers of methods in this class."
msgstr ""

#: gino.engine.GinoConnection:7 of
msgid ""
"Usually instances of this class are created by "
":meth:`.GinoEngine.acquire`."
msgstr ""

#: gino.engine.GinoConnection:11 of
msgid ""
":class:`.GinoConnection` may refer to zero or one underlying database "
"connection - when a :class:`.GinoConnection` is acquired with "
"``lazy=True``, the underlying connection may still be in the pool, until "
"a query API is called or :meth:`get_raw_connection` is called."
msgstr ""

#: gino.engine.GinoConnection:16 of
msgid ""
"Oppositely, one underlying database connection can be shared by many "
":class:`.GinoConnection` instances when they are acquired with "
"``reuse=True``. The actual database connection is only returned to the "
"pool when the **root** :class:`.GinoConnection` is released. Read more in"
" :meth:`GinoEngine.acquire` method."
msgstr ""

#: gino.engine.GinoConnection:24 gino.engine.GinoEngine:11 of
msgid ":doc:`/explanation/engine`"
msgstr ""

#: gino.engine.GinoConnection.all:1 of
msgid "Runs the given query in database, returns all results as a list."
msgstr ""

#: gino.engine.GinoConnection.all:3 of
msgid ""
"This method accepts the same parameters taken by SQLAlchemy "
":meth:`~sqlalchemy.engine.Connectable.execute`. You can pass in a raw SQL"
" string, or *any* SQLAlchemy query clauses."
msgstr ""

#: gino.engine.GinoConnection.all:7 of
msgid ""
"If the given query clause is built by CRUD models, then the returning "
"rows will be turned into relevant model objects (Only one type of model "
"per query is supported for now, no relationship support yet). See "
":meth:`execution_options` for more information."
msgstr ""

#: gino.engine.GinoConnection.all:12 of
msgid ""
"If the given parameters are parsed as \"executemany\" - bulk inserting "
"multiple rows in one call for example, the returning result from database"
" will be discarded and this method will return ``None``."
msgstr ""

#: gino.engine.GinoConnection.dialect:1 of
msgid ""
"The :class:`~sqlalchemy.engine.interfaces.Dialect` in use, inherited from"
" the engine created this connection."
msgstr ""

#: gino.engine.GinoConnection.execution_options:1 of
msgid "Set non-SQL options for the connection which take effect during execution."
msgstr ""

#: gino.engine.GinoConnection.execution_options:4 of
msgid ""
"This method returns a copy of this :class:`.GinoConnection` which "
"references the same underlying database connection, but with the given "
"execution options set on the copy. Therefore, it is a good practice to "
"discard the copy immediately after use, for example::"
msgstr ""

#: gino.engine.GinoConnection.execution_options:11 of
msgid ""
"This is very much the same as SQLAlchemy "
":meth:`~sqlalchemy.engine.base.Connection.execution_options`, it actually"
" does pass the execution options to the underlying SQLAlchemy "
":class:`~sqlalchemy.engine.base.Connection`. Furthermore, GINO added a "
"few execution options:"
msgstr ""

#: gino.engine.GinoConnection.execution_options
#: gino.engine.GinoConnection.get_raw_connection gino.engine.GinoEngine.acquire
#: of
msgid "Parameters"
msgstr ""

#: gino.engine.GinoConnection.execution_options:17 of
msgid ""
"Boolean to control whether the returning results should be loaded into "
"model instances, where the model class is defined in another execution "
"option ``model``. Default is ``True``."
msgstr ""

#: gino.engine.GinoConnection.execution_options:21 of
msgid ""
"Specifies the type of model instance to create on return. This has no "
"effect if ``return_model`` is set to ``False``. Usually in queries built "
"by CRUD models, this execution option is automatically set. For now, GINO"
" only supports loading each row into one type of model object, "
"relationships are not supported. Please use multiple queries for that. "
"``None`` for no postprocessing (default)."
msgstr ""

#: gino.engine.GinoConnection.execution_options:28 of
msgid ""
"Seconds to wait for the query to finish. ``None`` for no time out "
"(default)."
msgstr ""

#: gino.engine.GinoConnection.execution_options:31 of
msgid ""
"A loader expression to load the database rows into specified objective "
"structure. It can be either:  * A model class, so that the query will "
"yield model instances of this   class. It is your responsibility to make "
"sure all the columns of   this model is selected in the query. * A "
":class:`~sqlalchemy.schema.Column` instance, so that each result   will "
"be only a single value of this column. Please note, if you   want to "
"achieve fetching the very first value, you should use   "
":meth:`~gino.engine.GinoConnection.first` instead of   "
":meth:`~gino.engine.GinoConnection.scalar`. However, using directly   "
":meth:`~gino.engine.GinoConnection.scalar` is a more direct way. * A "
"tuple nesting more loader expressions recursively. * A :func:`callable` "
"function that will be called for each row to   fully customize the "
"result. Two positional arguments will be passed   to the function: the "
"first is the :class:`row   <sqlalchemy.engine.RowProxy>` instance, the "
"second is a context   object which is only present if nested else "
"``None``. * A :class:`~gino.loader.Loader` instance directly. * Anything "
"else will be treated as literal values thus returned as   whatever they "
"are."
msgstr ""

#: gino.engine.GinoConnection.execution_options:31 of
msgid ""
"A loader expression to load the database rows into specified objective "
"structure. It can be either:"
msgstr ""

#: gino.engine.GinoConnection.execution_options:34 of
msgid ""
"A model class, so that the query will yield model instances of this "
"class. It is your responsibility to make sure all the columns of this "
"model is selected in the query."
msgstr ""

#: gino.engine.GinoConnection.execution_options:37 of
msgid ""
"A :class:`~sqlalchemy.schema.Column` instance, so that each result will "
"be only a single value of this column. Please note, if you want to "
"achieve fetching the very first value, you should use "
":meth:`~gino.engine.GinoConnection.first` instead of "
":meth:`~gino.engine.GinoConnection.scalar`. However, using directly "
":meth:`~gino.engine.GinoConnection.scalar` is a more direct way."
msgstr ""

#: gino.engine.GinoConnection.execution_options:43 of
msgid "A tuple nesting more loader expressions recursively."
msgstr ""

#: gino.engine.GinoConnection.execution_options:44 of
msgid ""
"A :func:`callable` function that will be called for each row to fully "
"customize the result. Two positional arguments will be passed to the "
"function: the first is the :class:`row <sqlalchemy.engine.RowProxy>` "
"instance, the second is a context object which is only present if nested "
"else ``None``."
msgstr ""

#: gino.engine.GinoConnection.execution_options:49 of
msgid "A :class:`~gino.loader.Loader` instance directly."
msgstr ""

#: gino.engine.GinoConnection.execution_options:50 of
msgid ""
"Anything else will be treated as literal values thus returned as whatever"
" they are."
msgstr ""

#: gino.engine.GinoConnection.first:1 gino.engine.GinoConnection.scalar:1 of
msgid "Runs the given query in database, returns the first result."
msgstr ""

#: gino.engine.GinoConnection.first:3 gino.engine.GinoConnection.scalar:3 of
msgid "If the query returns no result, this method will return ``None``."
msgstr ""

#: gino.engine.GinoConnection.first:5 gino.engine.GinoConnection.one:8
#: gino.engine.GinoConnection.one_or_none:7 gino.engine.GinoConnection.scalar:5
#: of
msgid "See :meth:`all` for common query comments."
msgstr ""

#: gino.engine.GinoConnection.get_raw_connection:1 of
msgid "Get the underlying database connection, acquire one if none present."
msgstr ""

#: gino.engine.GinoConnection.get_raw_connection:3 of
msgid "Seconds to wait for the underlying acquiring"
msgstr ""

#: gino.engine.GinoConnection.get_raw_connection gino.engine.GinoEngine.acquire
#: gino.engine.GinoEngine.current_connection gino.engine.GinoEngine.transaction
#: of
msgid "Returns"
msgstr ""

#: gino.engine.GinoConnection.get_raw_connection:4 of
msgid "Underlying database connection instance depending on the dialect in use"
msgstr ""

#: gino.engine.GinoConnection.get_raw_connection of
msgid "raises"
msgstr ""

#: gino.engine.GinoConnection.get_raw_connection:6 of
msgid ":class:`~asyncio.TimeoutError` if the acquiring timed out"
msgstr ""

#: gino.engine.GinoConnection.iterate:1 gino.engine.GinoEngine.iterate:1 of
msgid "Creates a server-side cursor in database for large query results."
msgstr ""

#: gino.engine.GinoConnection.iterate:3 of
msgid "Cursors must work within transactions::"
msgstr ""

#: gino.engine.GinoConnection.iterate:9 of
msgid "Alternatively, you can manually control how the cursor works::"
msgstr ""

#: gino.engine.GinoConnection.iterate:16 of
msgid "Read more about how :class:`~gino.dialects.base.Cursor` works."
msgstr ""

#: gino.engine.GinoConnection.iterate:18 of
msgid "Similarly, this method takes the same parameters as :meth:`all`."
msgstr ""

#: gino.engine.GinoConnection.one:1 of
msgid "Runs the given query in database, returns exactly one result."
msgstr ""

#: gino.engine.GinoConnection.one:3 of
msgid ""
"If the query returns no result, this method will raise "
":class:`~gino.exceptions.NoResultFound`. If the query returns multiple "
"results, this method will raise "
":class:`~gino.exceptions.MultipleResultsFound`."
msgstr ""

#: gino.engine.GinoConnection.one_or_none:1 of
msgid "Runs the given query in database, returns at most one result."
msgstr ""

#: gino.engine.GinoConnection.one_or_none:3 of
msgid ""
"If the query returns no result, this method will return ``None``. If the "
"query returns multiple results, this method will raise "
":class:`~gino.exceptions.MultipleResultsFound`."
msgstr ""

#: gino.engine.GinoConnection.raw_connection:1 of
msgid ""
"The current underlying database connection instance, type depends on the "
"dialect in use. May be ``None`` if self is a lazy connection."
msgstr ""

#: gino.engine.GinoConnection.release:1 of
msgid "Returns the underlying database connection to its pool."
msgstr ""

#: gino.engine.GinoConnection.release:3 of
msgid ""
"If ``permanent=False``, this connection will be set in lazy mode with "
"underlying database connection returned, the next query on this "
"connection will cause a new database connection acquired. This is useful "
"when this connection may still be useful again later, while some long-"
"running I/O operations are about to take place, which should not take up "
"one database connection or even transaction for that long time."
msgstr ""

#: gino.engine.GinoConnection.release:10 of
msgid ""
"Otherwise with ``permanent=True`` (default), this connection will be "
"marked as closed after returning to pool, and be no longer usable again."
msgstr ""

#: gino.engine.GinoConnection.release:14 of
msgid ""
"If this connection is a reusing connection, then only this connection is "
"closed (depending on ``permanent``), the reused underlying connection "
"will **not** be returned back to the pool."
msgstr ""

#: gino.engine.GinoConnection.release:18 of
msgid ""
"Practically it is recommended to return connections in the reversed order"
" as they are borrowed, but if this connection is a reused connection with"
" still other opening connections reusing it, then on release the "
"underlying connection **will be** returned to the pool, with all the "
"reusing connections losing an available underlying connection. The "
"availability of further operations on those reusing connections depends "
"on the given ``permanent`` value."
msgstr ""

#: gino.engine.GinoConnection.release:28 gino.engine.GinoEngine.transaction:23
#: of
msgid ":meth:`.GinoEngine.acquire`"
msgstr ""

#: gino.engine.GinoConnection.schema_for_object:1 of
msgid "A SQLAlchemy compatibility attribute, don't use it for now, it bites."
msgstr ""

#: gino.engine.GinoConnection.status:1 of
msgid "Runs the given query in database, returns the query status."
msgstr ""

#: gino.engine.GinoConnection.status:3 of
msgid ""
"The returning query status depends on underlying database and the dialect"
" in use. For asyncpg it is a string, you can parse it like this: "
"https://git.io/v7oze"
msgstr ""

#: gino.engine.GinoConnection.transaction:1 of
msgid "Starts a database transaction."
msgstr ""

#: gino.engine.GinoConnection.transaction:3 of
msgid ""
"There are two ways using this method: **managed** as an asynchronous "
"context manager::"
msgstr ""

#: gino.engine.GinoConnection.transaction:9 of
msgid "or **manually** awaited::"
msgstr ""

#: gino.engine.GinoConnection.transaction:19 of
msgid ""
"Where the ``tx`` is an instance of the "
":class:`~gino.transaction.GinoTransaction` class, feel free to read more "
"about it."
msgstr ""

#: gino.engine.GinoConnection.transaction:23 of
msgid ""
"In the first managed mode, the transaction is automatically committed on "
"exiting the context block, or rolled back if an exception was raised "
"which led to the exit of the context. In the second manual mode, you'll "
"need to manually call the "
":meth:`~gino.transaction.GinoTransaction.commit` or "
":meth:`~gino.transaction.GinoTransaction.rollback` methods on need."
msgstr ""

#: gino.engine.GinoConnection.transaction:30 of
msgid ""
"If this is a lazy connection, entering a transaction will cause a new "
"database connection acquired if none was present."
msgstr ""

#: gino.engine.GinoConnection.transaction:33 of
msgid ""
"Transactions may support nesting depending on the dialect in use. For "
"example in asyncpg, starting a second transaction on the same connection "
"will create a save point in the database."
msgstr ""

#: gino.engine.GinoConnection.transaction:37 of
msgid ""
"For now, the parameters are directly passed to underlying database "
"driver, read :meth:`asyncpg.connection.Connection.transaction` for "
"asyncpg."
msgstr ""

#: gino.engine.GinoEngine:1 of
msgid ""
"Connects a :class:`~.dialects.base.Pool` and "
":class:`~sqlalchemy.engine.interfaces.Dialect` together to provide a "
"source of database connectivity and behavior."
msgstr ""

#: gino.engine.GinoEngine:5 of
msgid ""
"A :class:`.GinoEngine` object is instantiated publicly using the "
":func:`gino.create_engine` function or :func:`db.set_bind() "
"<gino.api.Gino.set_bind>` method."
msgstr ""

#: gino.engine.GinoEngine.acquire:1 of
msgid "Acquire a connection from the pool."
msgstr ""

#: gino.engine.GinoEngine.acquire:3 of
msgid ""
"There are two ways using this method - as an asynchronous context "
"manager::"
msgstr ""

#: gino.engine.GinoEngine.acquire:9 of
msgid ""
"which will guarantee the connection is returned to the pool when leaving "
"the ``async with`` block; or as a coroutine::"
msgstr ""

#: gino.engine.GinoEngine.acquire:18 of
msgid ""
"where the connection should be manually returned to the pool with "
":meth:`conn.release() <.GinoConnection.release>`."
msgstr ""

#: gino.engine.GinoEngine.acquire:21 of
msgid ""
"Within the same context (usually the same :class:`~asyncio.Task`, see "
"also :doc:`/how-to/transaction`), a nesting acquire by default re"
msgstr ""

#: gino.engine.GinoEngine.acquire:24 of
msgid ""
"Block up to ``timeout`` seconds until there is one free connection in the"
" pool. Default is ``None`` - block forever until succeeded. This has no "
"effect when ``lazy=True``, and depends on the actual situation when "
"``reuse=True``."
msgstr ""

#: gino.engine.GinoEngine.acquire:29 of
msgid ""
"Reuse the latest reusable acquired connection (before it's returned to "
"the pool) in current context if there is one, or borrow a new one if none"
" present. Default is ``False`` for always borrow a new one. This is "
"useful when you are in a nested method call series, wishing to use the "
"same connection without passing it around as parameters. See also: :doc"
":`/how-to/transaction`. A reusing connection is not reusable even if "
"``reusable=True``. If the reused connection happened to be a lazy one, "
"then the reusing connection is lazy too."
msgstr ""

#: gino.engine.GinoEngine.acquire:39 of
msgid ""
"Don't acquire the actual underlying connection yet - do it only when "
"needed. Default is ``False`` for always do it immediately. This is useful"
" before entering a code block which may or may not make use of a given "
"connection object. Feeding in a lazy connection will save the borrow-"
"return job if the connection is never used. If setting ``reuse=True`` at "
"the same time, then the reused connection - if any - applies the same "
"laziness. For example, reusing a lazy connection with ``lazy=False`` will"
" cause the reused connection to acquire an underlying connection "
"immediately."
msgstr ""

#: gino.engine.GinoEngine.acquire:49 of
msgid ""
"Mark this connection as reusable or otherwise. This has no effect if it "
"is a reusing connection. All reusable connections are placed in a stack, "
"any reusing acquire operation will always reuse the top (latest) reusable"
" connection. One reusable connection may be reused by several reusing "
"connections - they all share one same underlying connection. Acquiring a "
"connection with ``reusable=False`` and ``reusing=False`` makes it a "
"cleanly isolated connection which is only referenced once here."
msgstr ""

#: gino.engine.GinoEngine.acquire:58 of
msgid "A :class:`.GinoConnection` object."
msgstr ""

#: gino.engine.GinoEngine.all:1 of
msgid ""
"Acquires a connection with ``reuse=True`` and runs "
":meth:`~.GinoConnection.all` on it. ``reuse=True`` means you can safely "
"do this without borrowing more than one underlying connection::"
msgstr ""

#: gino.engine.GinoEngine.all:8 of
msgid "The same applies for other query methods."
msgstr ""

#: gino.engine.GinoEngine.close:1 of
msgid "Close the engine, by closing the underlying pool."
msgstr ""

#: gino.engine.GinoEngine.compile:1 of
msgid ""
"A shortcut for :meth:`~gino.dialects.base.AsyncDialectMixin.compile` on "
"the dialect, returns raw SQL string and parameters according to the rules"
" of the dialect."
msgstr ""

#: gino.engine.GinoEngine.connection_cls:1 of
msgid ""
"Customizes the connection class to use, default is "
":class:`.GinoConnection`."
msgstr ""

#: gino.engine.GinoEngine.current_connection:1 of
msgid ""
"Gets the most recently acquired reusable connection in the context. "
"``None`` if there is no such connection."
msgstr ""

#: gino.engine.GinoEngine.current_connection:4 of
msgid ":class:`.GinoConnection`"
msgstr ""

#: gino.engine.GinoEngine.dialect:1 of
msgid ""
"Read-only property for the :class:`~sqlalchemy.engine.interfaces.Dialect`"
" of this engine."
msgstr ""

#: gino.engine.GinoEngine.first:1 of
msgid "Runs :meth:`~.GinoConnection.first`, See :meth:`.all`."
msgstr ""

#: gino.engine.GinoEngine.iterate:3 of
msgid ""
"This requires that there is a reusable connection in the current context,"
" and an active transaction is present. Then its "
":meth:`.GinoConnection.iterate` is executed and returned."
msgstr ""

#: gino.engine.GinoEngine.one:1 of
msgid "Runs :meth:`~.GinoConnection.one`, See :meth:`.all`."
msgstr ""

#: gino.engine.GinoEngine.one_or_none:1 of
msgid "Runs :meth:`~.GinoConnection.one_or_none`, See :meth:`.all`."
msgstr ""

#: gino.engine.GinoEngine.raw_pool:1 of
msgid ""
"Read-only access to the underlying database connection pool instance. "
"This depends on the actual dialect in use, :class:`~asyncpg.pool.Pool` of"
" asyncpg for example."
msgstr ""

#: gino.engine.GinoEngine.scalar:1 of
msgid "Runs :meth:`~.GinoConnection.scalar`, See :meth:`.all`."
msgstr ""

#: gino.engine.GinoEngine.status:1 of
msgid "Runs :meth:`~.GinoConnection.status`. See also :meth:`.all`."
msgstr ""

#: gino.engine.GinoEngine.transaction:1 of
msgid "Borrows a new connection and starts a transaction with it."
msgstr ""

#: gino.engine.GinoEngine.transaction:3 of
msgid ""
"Different to :meth:`.GinoConnection.transaction`, transaction on engine "
"level supports only managed usage::"
msgstr ""

#: gino.engine.GinoEngine.transaction:9 of
msgid ""
"Where the implicitly acquired connection is available as "
":attr:`tx.connection <gino.transaction.GinoTransaction.connection>`."
msgstr ""

#: gino.engine.GinoEngine.transaction:12 of
msgid ""
"By default, :meth:`.transaction` acquires connection with ``reuse=True`` "
"and ``reusable=True``, that means it by default tries to create a nested "
"transaction instead of a new transaction on a new connection. You can "
"change the default behavior by setting these two arguments."
msgstr ""

#: gino.engine.GinoEngine.transaction:18 of
msgid ""
"The other arguments are the same as :meth:`~.GinoConnection.transaction` "
"on connection."
msgstr ""

#: gino.engine.GinoEngine.transaction:25 of
msgid ":meth:`.GinoConnection.transaction`"
msgstr ""

#: gino.engine.GinoEngine.transaction:27 of
msgid ":class:`~gino.transaction.GinoTransaction`"
msgstr ""

#: gino.engine.GinoEngine.transaction:29 of
msgid ""
"A asynchronous context manager that yields a "
":class:`~gino.transaction.GinoTransaction`"
msgstr ""

#: gino.engine.GinoEngine.update_execution_options:1 of
msgid ""
"Update the default execution_options dictionary of this "
":class:`.GinoEngine`."
msgstr ""

#: gino.engine.GinoEngine.update_execution_options:6 of
msgid ":meth:`sqlalchemy.engine.Engine.update_execution_options`"
msgstr ""

#: gino.engine.GinoEngine.update_execution_options:8 of
msgid ":meth:`.GinoConnection.execution_options`"
msgstr ""

